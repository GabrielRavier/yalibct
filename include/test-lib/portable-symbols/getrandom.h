// Derived from code with this license:
/* Obtain a series of random bytes.

   Copyright 2020-2023 Free Software Foundation, Inc.

   This file is free software: you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of the
   License, or (at your option) any later version.

   This file is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */

/* Written by Paul Eggert.  */

#pragma once

#ifndef YALIBCT_LIBC_DOESNT_HAVE_GETRANDOM
#include <sys/random.h>
#else

#include "test-lib/portable-symbols/GRND_RANDOM.h"
#include "test-lib/portable-symbols/GRND_NONBLOCK.h"
#include <sys/types.h>
#include <stdbool.h>

/* These devices exist on all platforms except native Windows.  */

/* Name of a device through which the kernel returns high quality random
   numbers, from an entropy pool.  When the pool is empty, the call blocks
   until entropy sources have added enough bits of entropy.  */
# ifndef NAME_OF_RANDOM_DEVICE
#  define NAME_OF_RANDOM_DEVICE "/dev/random"
# endif

/* Name of a device through which the kernel returns random or pseudo-random
   numbers.  It uses an entropy pool, but, in order to avoid blocking, adds
   bits generated by a pseudo-random number generator, as needed.  */
# ifndef NAME_OF_NONCE_DEVICE
#  define NAME_OF_NONCE_DEVICE "/dev/urandom"
# endif

/* Set BUFFER (of size LENGTH) to random bytes under the control of FLAGS.
   Return the number of bytes written (> 0).
   Upon error, return -1 and set errno.  */
ssize_t
getrandom (void *buffer, size_t length, unsigned int flags)
//#undef getrandom
{
#if defined _WIN32 && ! defined __CYGWIN__
  /* BCryptGenRandom, defined in <bcrypt.h>
     <https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom>
     with the BCRYPT_USE_SYSTEM_PREFERRED_RNG flag
     works in Windows 7 and newer.  */
  static int bcrypt_not_working /* = 0 */;
  if (!bcrypt_not_working)
    {
# ifdef YALIBCT_LIBC_DOESNT_HAVE_LIB_BCRYPT
      if (!initialized)
        initialize ();
# endif
      if (BCryptGenRandomFunc != NULL
          && BCryptGenRandomFunc (NULL, buffer, length,
                                  BCRYPT_USE_SYSTEM_PREFERRED_RNG)
             == 0 /*STATUS_SUCCESS*/)
        return length;
      bcrypt_not_working = 1;
    }
# ifdef YALIBCT_LIBC_DOESNT_HAVE_LIB_BCRYPT
  /* CryptGenRandom, defined in <wincrypt.h>
     <https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptgenrandom>
     works in older releases as well, but is now deprecated.
     CryptAcquireContext, defined in <wincrypt.h>
     <https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptacquirecontexta>  */
  {
    static int crypt_initialized /* = 0 */;
    static HCRYPTPROV provider;
    if (!crypt_initialized)
      {
        if (CryptAcquireContext (&provider, NULL, NULL, PROV_RSA_FULL,
                                 CRYPT_VERIFY_CONTEXT))
          crypt_initialized = 1;
        else
          crypt_initialized = -1;
      }
    if (crypt_initialized >= 0)
      {
        if (!CryptGenRandom (provider, length, buffer))
          {
            errno = EIO;
            return -1;
          }
        return length;
      }
  }
# endif
  errno = ENOSYS;
  return -1;
#else
  static int randfd[2] = { -1, -1 };
  bool devrandom = (flags & GRND_RANDOM) != 0;
  int fd = randfd[devrandom];

  if (fd < 0)
    {
      static char const randdevice[][MAX (sizeof NAME_OF_NONCE_DEVICE,
                                          sizeof NAME_OF_RANDOM_DEVICE)]
        = { NAME_OF_NONCE_DEVICE, NAME_OF_RANDOM_DEVICE };
      int oflags = (O_RDONLY + O_CLOEXEC
                    + ((flags & GRND_NONBLOCK) ? O_NONBLOCK : 0));
      fd = open (randdevice[devrandom], oflags);
      if (fd < 0)
        {
          if (errno == ENOENT || errno == ENOTDIR)
            errno = ENOSYS;
          return -1;
        }
      randfd[devrandom] = fd;
    }

  return read (fd, buffer, length);
#endif
}

#endif
